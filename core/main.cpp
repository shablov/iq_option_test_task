#include <algorithm>
#include <atomic>
#include <fstream>
#include <functional>
#include <iostream>
#include <iterator>
#include <sstream>
#include <thread>

#include <arpa/inet.h>
#include <signal.h>
#include <sys/socket.h>
#include <unistd.h>

#include <libs/common.h>
#include <libs/event_generator.h>

static std::atomic< bool > stopped( false );

void receive_loop( const uint16_t receive_port )
{
	auto socket_fd = createSocket();
	bindSocket( socket_fd, receive_port );

	constexpr size_t buffer_length = 4096;
	std::string buffer( buffer_length, '\0' );
	while ( !stopped.load() ) {
		if ( auto readBytes = recv( socket_fd, buffer.data(), buffer.size(), 0 ); readBytes > 0 ) {
			std::copy( buffer.cbegin(), buffer.cbegin() + readBytes, std::ostream_iterator< char >( std::cout, "" ) );
			std::cout << "\n";
		}
	}

	close( socket_fd );
}

void send_loop( const char* send_address, const uint16_t send_port, const char* filename, const bool eventAutoGenerated )
{
	using namespace std::chrono_literals;

	const auto socket_fd = createSocket();
	const auto sockaddr = getRemoteSockaddr( send_address, send_port );

	auto send = [&socket_fd, &sockaddr]( const std::string_view str ) {
		std::this_thread::sleep_for( 1us );
		sendto( socket_fd, str.data(), str.size(), 0, reinterpret_cast< const struct sockaddr* >( &sockaddr ), sizeof( sockaddr ) );
	};

	if ( !eventAutoGenerated ) {
		std::ifstream in_file( filename, std::ios::binary );
		while ( !in_file.eof() && !stopped.load() ) {
			std::string str;
			std::getline( in_file, str );

			send( str );
		}
	}
	else {
		std::chrono::nanoseconds currentTime = std::chrono::nanoseconds::zero();
		EventGenerator eventGenerator;
		while ( !stopped.load() ) {
			auto event = eventGenerator.generateEvent( currentTime );
			if ( Event::Type::user_deal_won == event->type() ) {
				UserDealWonEvent& dealWonEvent = static_cast< UserDealWonEvent& >( *event );
				currentTime = dealWonEvent.time();
			}

			std::ostringstream ss;
			ss << *event << "\n";

			send( ss.str() );
		}
	}

	close( socket_fd );
}

int main( int argc, char* argv[] )
{
	if ( argc < 3 ) {
		return -1;
	}

	const uint16_t receive_port = static_cast< uint16_t >( std::stoul( argv[ 1 ] ) );
	const char* send_address = argv[ 2 ];
	const uint16_t send_port = static_cast< uint16_t >( std::stoul( argv[ 3 ] ) );
	const char* filename = ( argc < 4 ) ? nullptr : argv[ 4 ];
	const bool eventAutoGenerated = ( argc < 4 );

	signal( SIGINT, []( int ) { stopped.store( true ); } );

	std::thread receive_thread( std::bind( receive_loop, receive_port ) );

	std::thread send_thread( std::bind( send_loop, send_address, send_port, filename, eventAutoGenerated ) );

	send_thread.join();
	receive_thread.join();

	return 0;
}
